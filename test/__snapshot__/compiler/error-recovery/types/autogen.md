# Kataw parser test case

> Auto-generated tests to validate error recovery
>

## Input

### Cases

> `````js
> function*foo(a = yield) {
> `````

> `````js
> let
> `````

> `````js
> var v = () => {
> `````

> `````js
> abstract class AbstractRule {
> `````

> `````js
> function b(a) { return null;
> `````

> `````js
> string | &
> `````

> `````js
> (try f |= 1;
> `````

> `````js
> string[
> `````

> `````js
> new r();
> `````

> `````js
>  Array<new () => string
> `````

> `````js
> =>x
> `````

> `````js
> v = (a, b) => {
> `````

> `````js
> a: string
> `````

> `````js
> <U>
> `````

> `````js
> <U> {
> `````

> `````js
>  number): void;
> `````

> `````js
> string): void;
> `````

> `````js
> (n: number): void;
> `````

> `````js
> string | string[]
> `````

> `````js
>  Partial<T> = {};
> `````

> `````js
> T = t as
> `````

> `````js
> (ctrl: number|string) => void)[] = y;
> `````

> `````js
>  KeysByType<T, number
> `````

> `````js
> unknown): asserts value is
> `````

> `````js
> x!: string
> `````

> `````js
> const x!: string
> `````

> `````js
> "bar = 1
> `````

> `````js
> export class C {
> `````

> `````js
>  string {
> `````

> `````js
> );
> `````

> `````js
> <U extends object = { x: number }> = Array<
> `````

> `````js
> IActionMessage>{
> `````

> `````js
> IActionMessa
> `````

> `````js
> Iadsf
> `````

> `````js
> interface string {
> `````

> `````js
> interface Generic<T> {
> `````

> `````js
>   x: T;
> `````

> `````js
> c<number> = { x: 3 };
> `````

> `````js
>   A = 0,
> `````

> `````js
> { [index: number]:
> `````

> `````js
> <never>(
> `````

> `````js
> (a as number) = 42;
> `````

> `````js
> [1, true];
> `````

> `````js
> try {} catch (ex) {}
> `````

> `````js
> xport a: string) {
> `````

> `````js
>   b: 1
> `````

> `````js
>   b: 1)=(
> `````

> `````js
>   b: 1)=(%&
> `````

> `````js
>   b: 1)=(%&
> `````

> `````js
>  never[] | string[];
> `````

> `````js
> (try
> `````

> `````js
> catch
> `````

> `````js
> finally
> `````

> `````js
> false
> `````

> `````js
> function(){}
> `````

> `````js
> new x
> `````

> `````js
> null
> `````

> `````js
> true
> `````

> `````js
> this
> `````

> `````js
> typeof x
> `````

> `````js
> void x
> `````

> `````js
> x + y
> `````

> `````js
> [!.length
> `````

> `````js
!ax=((())
> `````

> `````js
> .length
> `````

> `````js
> a..
> `````

> `````js
> switch a..
> `````

> `````js
> )=..
> `````

> `````js
> a../
> `````

> `````js
> a..`
> `````

> `````js
> a`..
> `````


> `````js
> dsafdsf
> `````

> `````js
> {!
> `````

> `````js
> never break?=
> `````

> `````js
> try catch & finally in bethlehem
> `````

> `````js
> foo const
> `````

> `````js
> let const
> `````

> `````js
> export var let const function
> `````

> `````js
> export interface
> `````

> `````js
> type x = !
> `````

> `````js
> type x
> `````

> `````js
> K())&(%€a..
> `````

> `````js
> function let: string =
> `````

> `````js
> a..!
> `````

> `````js
> x function y (string: void
> `````

> `````js
> ??=)(=/LDFKa..
> `````

> `````js
> a&)(&/)
> `````

> `````js
> )(=(()))
> `````

> `````js
> &/)(=LFØD)
> `````

> `````js
> &/()=YJ function
> `````

> `````js
> &/()HN
> `````

> `````js
> a.)))))
> `````

> `````js
> )=?)a..
> `````


> `````js
> class ! switch
> `````

> `````js
> with
> `````

> `````js
> while
> `````

> `````js
> a..!for
> `````

> `````js
> for
> `````

> `````js
> if
> `````

> `````js
> if..
> `````

> `````js
> else..
> `````

> `````js
> switch..
> `````

> `````js
> =( ?
> `````

> `````js
> a..!!??!!??for x in z = v
> `````

> `````js
> /()
> `````

> `````js
> ?..
> `````

> `````js
> a.?.
> `````

> `````js
> a??..
> `````

> `````js
> ??a..??
> `````

> `````js
> )j
> `````

> `````js
> 123
> `````

> `````js
> &/)=)==?)=
> `````

> `````js
> hang mann ! switch while do this function x(
> `````

> `````js
> ??
> `````

> `````js
> a..
> `````

> `````js
> a/&..
> `````

> `````js
> )..
> `````

> `````js
> = 1
> `````

> `````js
> a=
> `````

> `````js
> ((a..?
> `````

> `````js
> /aaaaaaaaa
> `````

> `````js
> if x y z !== y function
> `````

> `````js
> switch case default x!
> `````

> `````js
> enum x {{{{{{{{
> `````

> `````js
> interface x }
> `````

> `````js
> }}
> `````

> `````js
> {
> `````

> `````js
> {}..
> `````

> `````js
> €
> `````

> `````js
> function!aladdin switch ((()))
> `````

> `````js
> a,,,,!$
> `````

> `````js
> let a:
> `````

> `````js
> ..
> `````







### Templates

#### stand-alone

`````js
[ # ]
`````

#### in function param

property is valid assignment target so should work

`````js
function ( # ) ;
`````

#### in function param with block

`````js
function ( # ) {#}
`````

#### in arrow head

`````js
([ # , x: # ]) => {}
`````

#### in async arrow head

`````js
async ([ # , x: # ]) => {}
`````

#### in interface

`````js
interface # {}
`````

#### in type alias

`````js
type # = x extends #
`````

#### in declare

`````js
declare #
`````

#### with abstract modifier

`````js
absrtact #
`````

#### in class

`````js
# class # { field: #}
`````

#### in class expr

`````js
(class { field: # })
`````

#### in async arrow head

`````js
async ([ # , x: # ]) => {}
`````

#### export assign

`````js
export # = #
`````

#### in import assign

`````js
import # = # ;
`````

#### in call expr

`````js
x(#)
`````

#### lexical let

`````js
let x: # #
`````

#### lexical const

`````js
const x: #= {x:#}:#
`````

#### in variable stmt

`````js
var x!:
`````

#### in lhs

`````js
 function (x:# = #) {}
`````

#### in block in variable stmt

`````js
{ var x!: }
`````

### Printed

```javascript
@{x2716}@ Soon to be open sourced
```

### Diagnostics

```javascript

```

